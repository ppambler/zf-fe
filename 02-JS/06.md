# 06-闭包作业复习1

## ★作业

### <mark>1）题一</mark>

``` js
let x = 5;
function fn(x) {
    return function(y) {
        console.log(y + (++x));
    }
}
let f = fn(6);
f(7);
fn(8)(9);
f(10);
console.log(x);
```

分析：

1、EC(G)

1. ECStack
   1. VO
      1. x -> 5
      2. fn -> `0x101`
         1. 代码字符串+键值对
         2. init `[[scope]] -> VO(G)` 
      3. f
         1. `fn(6)`执行

2、EC(fn)

1. `fn(6)`
   1. init `[[scopeChain]] -> VO(G)`
   2. init AO
      1. arguments -> `{0:6}`
      2. x -> 6
      3. 代码执行
         1. 返回 `0x102`

3、EC

1. `f(7)` -> scopeChain `AO(fn)` -> 7+6+1 = 14 -> `AO(fn)`(x=7)
2. `fn(8)(9)` -> 9+8+1 = 18 -> `AO(fn)`(x=9)
3. `f(10)` -> 10+7+1 = 18
4. `console.log(x)` -> 5

4、结果：

14、18、18、5

> 测试运行情况：正确

个人认为考察点：

- A和B都闭包同一个上下文，A家的会不会影响B家的！
- `let a = 10;` -> `5 + (++a)` 与 `5 + (a++)`的区别，前者`(++a)`+1完再返回，而后者则是直接返回此刻`a`的值 -> 说白了，一个前置递增（level 16）与一个后置递增（level 17）的pk

### <mark>2）题二</mark>

``` js
let x = 5;
function fn() {
    return function(y) {
        console.log(y + (++x));
    }
}
let f = fn(6);
f(7);
fn(8)(9);
f(10);
console.log(x);
```

分析：

1、EC(G)

- VO
  - x = 5
  - fn = 0x101
  - f = 0x102

- f(7) -> 7+5+1 = 13 -> a = 5+1 = 6
- fn(8)(9) -> 9+6+1 = 16 -> a = 6+1 = 7
- f(10) -> 10+7+1 = 18 -> a = 7+1 = 8

2、EC(fn)

- VO
  - arguments -> `{0:6}`
- `return 0x102`

3、结果

13、16、18、8

> 测试正确

个人认为考察点：

- 共享全局闭包

### <mark>3）题三</mark>

``` js
let a=0,
    b=0;
function A(a){
    A=function(b){
        alert(a+b++);
    };
    alert(a++);
}
A(1);
A(2);
```

分析：

1、EC(G)

- VO
  - a -> 0
  - b -> 0
  - A -> 0x101 -> 0x102（调用自己的时候改变自己？）

2、EC(A)

- AO(A)
  - arguments -> `{0:1}`
  - a -> `1` -> 1+1 = 2
- `alert(a++)` -> 1

3、EC(A)

- `A(2)`
  - arguments -> `{0:2}`
  - b -> `2` -> 2+1 = 3
- `alert(a+b++)` -> `a+(b++)` -> 2+2 = 4

4、结果

1、4

> 测试正确

归纳一下自己如何分析：

1. 直接看`EC(G)`和`EC(函数)`
2. 只写变量的状态以及变量状态变化过程 -> 只分析VO/AO
3. 涉及到函数，就用 `0x101`、`0x102`这样的过程
4. 作用域和作用域链不需要分析，潜意识就应该有了吧

> 我发现做了几道题后，不会写代码了，只会看这些代码……

### <mark>3）题四</mark>

``` js
var x = 3,
    obj = {x: 5};
obj.fn = (function () {
    this.x *= ++x;
    return function (y) {
        this.x *= (++x)+y;
        console.log(x);
    }
})();
var fn = obj.fn;
obj.fn(6);
fn(4);
console.log(obj.x, x);
```

分析：

1、EC(G)

- VO
  - x -> 3 -> 4 -> 12 -> 13 -> 234
  - obj -> 0xJ101（普通对象用`J`作为前缀）`{x:5}` -> `x:95`
  - fn -> undefined -> `0xF101`

- `obj.fn` -> `0xF101`
- `obj.fn(6)`
- `fn(4)`
- `console.log(obj.x, x);` -> 95,234

2、EC(fn)

- this -> window
- `this.x *= ++x` <=> `window.x = (window.x) * (++x)` -> `window.x` = `3 * (3+1) = 12`
- `return 0xF101`

3、EC(0xF101)

- this -> obj(0xJ101)
- arguments -> `{0:6}`
- y -> 6

- `this.x *= (++x)+y;` <=> `this.x = (this.x) * ((++x)+y);` -> `5 * (13+6) = 95`

- `console.log(x);` -> 13

4、EC(0xF101)

- y -> 4
- this -> window

- `this.x *= (++x)+y;` -> `13 * ((13+1) + 4) = 234`

- `console.log(x);` -> 234

5、结果

1. 13
2. 234
3. 95,234

> 测试答案正确

> 在计算的时候，注意`成员访问`（即`.`）的level是19，以及 `A += B + C` 、`A *= B + C` 都是 `A = A+(B+C)`、`A = A*(B+C)`

---










