| ✍️ Tangxt | ⏳ 2020-08-01 | 🏷️ DOM 事件 |

# 36-事件对象和事件的传播机制

## ★事件对象

1）为事件绑定监听函数

我们知道浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。而这是事件驱动编程模式（event-driven）的主要编程方式。

在 JS 里边，有三种方法，可以为事件绑定监听函数：

1、HTML 的 `on-` 属性

``` html
<body onload="doSomething()">
  <div onclick="console.log('触发事件')">

    <!-- 错误 -->

    <body onload="doSomething">
```

元素的**事件监听属性**，都是 `on` 加上事件名，比如 `onload` 就是 `on + load` ，表示 `load` 事件的监听代码。

注意，这些**属性的值是将会执行的代码**，而不是一个函数

``` js
el.setAttribute('onclick', 'doSomething()');
// 等同于
// <Element onclick="doSomething()">
```

2、元素节点的事件属性

元素节点对象的事件属性，同样可以指定监听函数。

``` js
window.onload = doSomething;

div.onclick = function(event) {
  console.log('触发事件');
};
```

![绑定监听函数](assets/img/2020-08-01-23-15-01.png)

3、EventTarget.addEventListener()

所有 DOM 节点实例都有 `addEventListener` 方法，用来为该节点定义事件的监听函数。

``` js
window.addEventListener('load', doSomething, false);
```

4、小结

* HTML 的 `on-` 属性：违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工 -> 不推荐使用
* 元素节点的事件属性：同一个事件只能定义一个监听函数，也就是说，如果定义两次 `onclick` 属性，后一次定义会覆盖前一次 -> 不推荐使用
* `EventTarget.addEventListener` 是推荐的指定监听函数的方法，优点如下：
  + **同一个事件**可以添加**多个**监听函数
  + 能够**指定在哪个阶段**（捕获阶段还是冒泡阶段）触发监听函数
  + 除了 DOM 节点，其他对象（比如 `window` 、 `XMLHttpRequest` 等）也有这个接口，它等于是**整个 JavaScript 统一的监听函数接口**

2）事件对象是怎么产生的？

**事件发生**以后，会产生一个**事件对象**，**作为参数传给监听函数**。浏览器原生提供一个 `Event` 对象，所有的事件都是这个对象的实例，或者说继承了 `Event.prototype` 对象。

如我们 `click` 一个 DOM 节点，触发它的监听函数：

拿到的事件对象就是：

![MouseEvent](assets/img/2020-08-01-23-27-11.png)

`MouseEvent` 的「继承」关系：

``` 
MouseEvent -> UIEvent -> Event -> Object
```

具体点来说：

> 当前元素的某个事件行为被触发，不仅会把绑定的方法执行，还会给绑定的方法**传递一个实参**，这个实参就是**事件对象**；
>  
> 事件对象就是用来**存储当前行为操作相关信息**的对象；（MosueEvent/KeyboardEvent/Event/TouchEvent...） -> 事件对象和在哪个方法中拿到的没关系，它记录的是当前操作的信息

3） `MouseEvent` 对象中常用的属性：

自有的属性：

* cancelBubble
* **target**（事件源 触发的元素） & srcElement（兼容 IE6~8 的写法，一般不考虑）
* **type**（事件类型 `'click'` ）
* code & key
* keyCode & which
* which / keyCode
* **clientX / clientY**（当前鼠标触发点距离当前**窗口左上角**的 X/Y 轴坐标，**无视第一屏、第二屏……**）
* **pageX / pageY**（当前鼠标触发点距离当前**页面 Body 左上角**的 X/Y 轴坐标，**出现在第二屏那么就得这样算了「 `clientY` +卷去的高度」**，不兼容 IE 低版本浏览器）
* path

公有的属性（来自 `Event` ）：

* **preventDefault**（阻止默认行为 `ev.preventDefaul` ，兼容处理 `ev.returnValue = false` ）
* **stopPropagation**（阻止它的冒泡传播 `ev.stopPropagation` ，兼容处理 `ev.cancelBubble = true` )

> 红色高亮的属性是常用的！

4）键盘事件对象

> KeyboardEvent -> UIEvent -> Event -> Object

``` js
document.onkeydown = function(e) {
  console.log(e)
}
```

键盘事件是不用知道你在哪个位置按下的，不像鼠标事件那样，得要知道在哪个位置 `click` 一样……

![键盘](assets/img/2020-08-02-01-44-03.png)

> [UI Events KeyboardEvent code Values](https://www.w3.org/TR/uievents-code/)

常用的属性：

* keyCode/which（获取键盘码，如 `code: "KeyD"、key: "D"、keyCode: 68、which: 68` ）
* 空格键（32）
* Enter（13） -> 表单回车提交
* BackSpace（8）
* Del（46）
* Shift（16）、Ctrl（17）、Alt（18）
* 四个方向键（左 37、上 38、右 39、下 40）
* 组合键（假如你按下 `D` 键，键盘事件对象的 altKey、ctrlKey、shiftKey 都为 `true` 的话，那么这就意味着按 `D` 键前， `Ctrl+Shift+Alt` 是没有松手的）
* 其它同鼠标事件对象一样

其它键对应的键盘码：

* [JavaScript Event KeyCodes](https://keycode.info/)
* [KeyboardEvent Value (keyCodes, metaKey, etc)](https://css-tricks.com/snippets/javascript/javascript-keycodes/)

![键盘键值表](assets/img/2020-08-02-01-51-09.png)

5）普通事件对象（ `Event` ）

``` js
window.onload = function(e) {
  console.log(e)
}
```

![Event实例](assets/img/2020-08-02-23-07-36.png)

6）移动端的手指事件对象

> PC浏览器访问 -> 切换到手机模拟器

``` js
box.ontouchstart = function(ev) {
  console.log(ev)
  // 获取第一个手指信息 -> 存储了clientX等基本信息
  let point = ev.changedTouches[0]
}
```

![手指事件对象](assets/img/2020-08-03-01-17-07.png)

* touchs：只能获取手指在屏幕上的时候的信息，如果手指离开了，信息就没了
* changedTouches：相对于 `touchs` 来讲可以获取到手指离开前的信息 -> 所以项目中用 `changedTouches` 最多

形象点来说：

![手指信息](assets/img/2020-08-03-01-33-05.png)

➹：[TouchEvent里的targetTouches、touches、changedTouches的区别的具体体现是？](https://segmentfault.com/q/1010000002870710)

➹：[移动端的touch事件（三） - 前端学习](http://www.zhangyunling.com/235.html)

## ★事件的默认行为 & 事件传播

1）事件的默认行为

默认行为：**很多元素天生具备一些默认的行为** -> 也就是说事件触发了就会有天生的肉眼可见的效果出现，就像是蜜蜂采蜜、蚂蚁筑巢等这样的先天性行为（生来就有的本能行为）

映射到页面就是：

1. 点击 `a` 标签时居然会实现页面的跳装 -> 如果你写锚点 `#xxx` ，那么也会有默认的锚点定位行为
2. 当我们 `focus` 一个文本输入框时居然可以输入内容
3. 在部分情况下，文本框居然会存在输入记忆
4. 鼠标按右键居然会出现右键菜单
5. ……

阻止事件的默认行为：

如

阻止右键菜单：

``` js
window.oncontextmenu = function(e) {
  e.preventDefault()
  // 接下来自己构建一个属于自己的右键菜单 -> 搞个div -> 监听鼠标点击的位置……
}
```

阻止超链接跳转或者说阻止页面刷新或者说阻止url尾巴出现`#xxx`：

``` html
<a href="#box">百度一下</a>
<a href="https://www.baidu.com" id="link">百度一下</a>
```

``` js
link.onclick = function(e) {
  // 点击 a 标签时都是先触发 click 然后再去跳转的
  // 在此处阻止默认行为它也就不跳转了！ -> 而且如果href是`#xxx`的话，点击跳到某个锚点也被阻止了，即url最后边不会加上#xxx
  e.preventDefault()
}
```

关于阻止超链接跳转，还有一种阻止默认行为的方式：

``` html
<a href="javascript:;">百度一下</a>
```

题外话：

- 点击文本输入框是先聚焦 `focus()`，然后`click()` -> 如果你用`tab`键聚焦到文本输入框的话，那么是不会触发`click`事件的 -> 总之，我们能输入文本是`focus`事件触发的先天行为…… -> 类似于那个`contenteditable`属性一样

2）事件的传播机制


