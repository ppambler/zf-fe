| ✍️ Tangxt | ⏳ 2020-08-01 | 🏷️ DOM 事件 |

# 36-事件对象和事件的传播机制

## ★事件对象

1）为事件绑定监听函数

我们知道浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。而这是事件驱动编程模式（event-driven）的主要编程方式。

在 JS 里边，有三种方法，可以为事件绑定监听函数：

1、HTML 的 `on-` 属性

``` html
<body onload="doSomething()">
  <div onclick="console.log('触发事件')">

    <!-- 错误 -->

    <body onload="doSomething">
```

元素的**事件监听属性**，都是 `on` 加上事件名，比如 `onload` 就是 `on + load` ，表示 `load` 事件的监听代码。

注意，这些**属性的值是将会执行的代码**，而不是一个函数

``` js
el.setAttribute('onclick', 'doSomething()');
// 等同于
// <Element onclick="doSomething()">
```

2、元素节点的事件属性

元素节点对象的事件属性，同样可以指定监听函数。

``` js
window.onload = doSomething;

div.onclick = function(event) {
  console.log('触发事件');
};
```

![绑定监听函数](assets/img/2020-08-01-23-15-01.png)

3、EventTarget.addEventListener()

所有 DOM 节点实例都有 `addEventListener` 方法，用来为该节点定义事件的监听函数。

``` js
window.addEventListener('load', doSomething, false);
```

4、小结

* HTML 的 `on-` 属性：违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工 -> 不推荐使用
* 元素节点的事件属性：同一个事件只能定义一个监听函数，也就是说，如果定义两次 `onclick` 属性，后一次定义会覆盖前一次 -> 不推荐使用
* `EventTarget.addEventListener` 是推荐的指定监听函数的方法，优点如下：
  + **同一个事件**可以添加**多个**监听函数
  + 能够**指定在哪个阶段**（捕获阶段还是冒泡阶段）触发监听函数
  + 除了 DOM 节点，其他对象（比如 `window` 、 `XMLHttpRequest` 等）也有这个接口，它等于是**整个 JavaScript 统一的监听函数接口**

2）事件对象是怎么产生的？

**事件发生**以后，会产生一个**事件对象**，**作为参数传给监听函数**。浏览器原生提供一个 `Event` 对象，所有的事件都是这个对象的实例，或者说继承了 `Event.prototype` 对象。

如我们 `click` 一个 DOM 节点，触发它的监听函数：

拿到的事件对象就是：

![MouseEvent](assets/img/2020-08-01-23-27-11.png)

`MouseEvent` 的「继承」关系：

``` 
MouseEvent -> UIEvent -> Event -> Object
```

具体点来说：

> 当前元素的某个事件行为被触发，不仅会把绑定的方法执行，还会给绑定的方法**传递一个实参**，这个实参就是**事件对象**；
> 
> 事件对象就是用来**存储当前行为操作相关信息**的对象；（MosueEvent/KeyboardEvent/Event/TouchEvent...） -> 事件对象和在哪个方法中拿到的没关系，它记录的是当前操作的信息

3） `MouseEvent` 对象中常用的属性：

自有的属性：

* cancelBubble
* **target**（事件源 触发的元素） & srcElement（兼容 IE6~8 的写法，一般不考虑）
* **type**（事件类型 `'click'` ）
* code & key
* keyCode & which
* which / keyCode
* **clientX / clientY**（当前鼠标触发点距离当前**窗口左上角**的 X/Y 轴坐标，**无视第一屏、第二屏……**）
* **pageX / pageY**（当前鼠标触发点距离当前**页面 Body 左上角**的 X/Y 轴坐标，**出现在第二屏那么就得这样算了「 `clientY` +卷去的高度」**，不兼容 IE 低版本浏览器）
* path

公有的属性（来自 `Event` ）：

* **preventDefault**（阻止默认行为 `ev.preventDefaul` ，兼容处理 `ev.returnValue = false` ）
* **stopPropagation**（阻止它的冒泡传播 `ev.stopPropagation` ，兼容处理 `ev.cancelBubble = true` )

> 红色高亮的属性是常用的！

4）键盘事件对象

> KeyboardEvent -> UIEvent -> Event -> Object

``` js
document.onkeydown = function(e) {
  console.log(e)
}
```

键盘事件是不用知道你在哪个位置按下的，不像鼠标事件那样，得要知道在哪个位置`click`一样……

![键盘](assets/img/2020-08-02-01-44-03.png)

> [UI Events KeyboardEvent code Values](https://www.w3.org/TR/uievents-code/)

常用的属性：

- keyCode/which（获取键盘码，如`code: "KeyD"、key: "D"、keyCode: 68、which: 68`）
- 空格键（32）
- Enter（13） -> 表单回车提交
- BackSpace（8）
- Del（46）
- Shift（16）、Ctrl（17）、Alt（18）
- 四个方向键（左37、上38、右39、下40）
- 组合键（假如你按下`D`键，键盘事件对象的altKey、ctrlKey、shiftKey -都为`true`的话，那么这就意味着按`D`键前，`Ctrl+Shift+Alt`是没有松手的）
- 其它同鼠标事件对象一样

其它键对应的键盘码：

- [JavaScript Event KeyCodes](https://keycode.info/)
- [KeyboardEvent Value (keyCodes, metaKey, etc)](https://css-tricks.com/snippets/javascript/javascript-keycodes/)

![键盘键值表](assets/img/2020-08-02-01-51-09.png)







